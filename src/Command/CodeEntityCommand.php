<?php
declare(strict_types=1);

// File: src/Command/CodeEntityCommand.php
// Generate a Doctrine entity *only* from a Jsonl profile (no CSV/JSON/STDIN).
//
// Example:
//   bin/console code:entity data/wam-dywer.profile.json App\\Entity\\Wam --api
//
// This is profile-driven and opinionated:
//   - PK comes from --pk or profile["uniqueFields"][0] (no heuristics).
//   - MeiliIndex is generated by default.
//   - ApiPlatform metadata is optional via --api.
//   - Properties are PUBLIC with comments + ApiProperty description/example
//     derived from FieldStats.

namespace Survos\CodeBundle\Command;

use ApiPlatform\Doctrine\Orm\Filter\OrderFilter;
use ApiPlatform\Doctrine\Orm\Filter\SearchFilter;
use ApiPlatform\Metadata\ApiFilter;
use ApiPlatform\Metadata\ApiProperty;
use ApiPlatform\Metadata\ApiResource;
use ApiPlatform\Metadata\Get;
use ApiPlatform\Metadata\GetCollection;
use DateTimeImmutable;
use Doctrine\DBAL\Types\Types;
use Doctrine\ORM\Mapping\Column;
use Doctrine\ORM\Mapping\Entity;
use Doctrine\ORM\Mapping\Id;
use Nette\PhpGenerator\ClassType;
use Nette\PhpGenerator\Constant;
use Nette\PhpGenerator\Literal;
use Nette\PhpGenerator\PhpFile;
use Nette\PhpGenerator\PhpNamespace;
use Nette\PhpGenerator\Visibility;
use Survos\CodeBundle\Service\GeneratorService;
use Survos\JsonlBundle\Model\FieldStats;
use Survos\JsonlBundle\Model\JsonlProfile;
use Survos\MeiliBundle\Metadata\MeiliIndex;
use Symfony\Component\Console\Attribute\Argument;
use Symfony\Component\Console\Attribute\AsCommand;
use Symfony\Component\Console\Attribute\Option;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Style\SymfonyStyle;
use Symfony\Component\Filesystem\Filesystem;
use Symfony\Component\Serializer\Attribute\Groups;
use function Symfony\Component\String\u;

#[AsCommand('code:entity', 'Generate a Doctrine entity from a Jsonl profile (no CSV/JSON/STDIN).')]
final class CodeEntityCommand extends Command
{
    public function __construct(
        private readonly GeneratorService $generatorService, // currently unused, kept for BC / future
        private readonly string $projectDir,
    ) {
        parent::__construct();
    }

    public function __invoke(
        SymfonyStyle $io,
        #[Argument('Path to the Jsonl profile (e.g. data/wam-dywer.profile.json)')]
        string $profileFile,
        #[Argument('Fully-qualified entity class name (e.g. App\\Entity\\Wam)')]
        string $entityFqcn,
        #[Option('primary key name if known', name: 'pk')]
        ?string $primaryField = null,
        #[Option('Add a MeiliIndex attribute')]
        ?bool $meili = null,
        #[Option('Configure as an API Platform resource')]
        ?bool $api = null,
        #[Option('Overwrite existing files without confirmation', name: 'force')]
        bool $force = false,
    ): int {
        $io->title('Entity generator (profile-only) — ' . $this->projectDir);

        if (!\is_file($profileFile)) {
            $io->error(\sprintf('Profile file "%s" does not exist.', $profileFile));
            return Command::FAILURE;
        }

        // ---------------------------------------------------------------------
        // Load profile JSON
        // ---------------------------------------------------------------------
        try {
            $raw     = \file_get_contents($profileFile);
            $decoded = \json_decode($raw, true, 512, \JSON_THROW_ON_ERROR);
        } catch (\Throwable $e) {
            $io->error(\sprintf(
                'Failed to read/parse profile "%s": %s',
                $profileFile,
                $e->getMessage()
            ));
            return Command::FAILURE;
        }

        // Hydrate JsonlProfile for FieldStats helpers, but keep raw $decoded for uniqueFields/originalName.
        try {
            $profile = JsonlProfile::fromArray($decoded);
        } catch (\Throwable $e) {
            $io->error(\sprintf(
                'Failed to hydrate JsonlProfile from "%s": %s',
                $profileFile,
                $e->getMessage()
            ));
            return Command::FAILURE;
        }

        if (!\is_array($profile->fields) || $profile->fields === []) {
            $io->error('Profile has no fields. Aborting.');
            return Command::FAILURE;
        }

        $fieldNames   = \array_keys($profile->fields);
        $uniqueFields = $decoded['uniqueFields'] ?? [];
        if (!\is_array($uniqueFields)) {
            $uniqueFields = [];
        }

        // ---------------------------------------------------------------------
        // Determine entity namespace + class name from FQCN
        // ---------------------------------------------------------------------
        $pos = \strrpos($entityFqcn, '\\');
        if ($pos === false) {
            $io->error(\sprintf('Entity FQCN "%s" has no namespace separator.', $entityFqcn));
            return Command::FAILURE;
        }

        $entityNamespace = \substr($entityFqcn, 0, $pos);
        $entityName      = \substr($entityFqcn, $pos + 1);

        if ($entityName === '') {
            $io->error(\sprintf('Invalid entity FQCN "%s".', $entityFqcn));
            return Command::FAILURE;
        }

        // Guess repository FQCN: replace "\Entity\" with "\Repository\" if present, else append.
        if (\str_contains($entityNamespace, '\\Entity')) {
            $repoNamespace = \str_replace('\\Entity', '\\Repository', $entityNamespace);
        } else {
            $repoNamespace = $entityNamespace . '\\Repository';
        }
        $repoClass = $entityName . 'Repository';
        $repoFqcn  = $repoNamespace . '\\' . $repoClass;

        // ---------------------------------------------------------------------
        // Primary key selection (profile.uniqueFields / --pk only, no extra heuristics)
        // ---------------------------------------------------------------------
        if ($primaryField !== null) {
            if (!\array_key_exists($primaryField, $profile->fields)) {
                $io->error(\sprintf(
                    'Requested --pk="%s" not found in profile fields. Available: %s',
                    $primaryField,
                    \implode(', ', \array_keys($profile->fields))
                ));
                return Command::FAILURE;
            }
        } else {
            if ($uniqueFields !== []) {
                // Single source of truth: first unique field from profile JSON.
                $primaryField = (string) $uniqueFields[0];

                if (!\array_key_exists($primaryField, $profile->fields)) {
                    $io->error(\sprintf(
                        'Profile uniqueFields[0] = "%s" but that field is not present in profile->fields. Fix the profile JSON.',
                        $primaryField
                    ));
                    return Command::FAILURE;
                }
            } else {
                $io->error('No primary key specified and profile has no uniqueFields. Pass --pk=fieldName or fix the profile.');
                return Command::FAILURE;
            }
        }

        // Primary key property name (for MeiliIndex primaryKey), based on the
        // same transformation used for properties.
        $pkProp             = \preg_replace('/[^a-zA-Z0-9_]/', '_', $primaryField);
        $primaryKeyProperty = u((string) $pkProp)->camel()->toString();

        $meili ??= true; // default: generate MeiliIndex

        // ---------------------------------------------------------------------
        // Build entity
        // ---------------------------------------------------------------------
        $phpFile = new PhpFile();
        $phpFile->setStrictTypes();

        $ns = new PhpNamespace($entityNamespace);
        $ns->addUse(Entity::class);
        $ns->addUse(Column::class);
        $ns->addUse(Id::class);
        $ns->addUse(DateTimeImmutable::class);
        $ns->addUse(Types::class);
        $ns->addUse($repoFqcn);

        $class = new ClassType($entityName);
        $class->setFinal();
        $class->addComment('@generated by code:entity from profile');
        $class->addComment('@profile ' . $profileFile);

        $class->addAttribute(Entity::class, [
            'repositoryClass' => new Literal($repoClass . '::class'),
        ]);

        $filterable = [];
        $sortable   = [];
        $searchable = [];

        $code      = u($entityName)->camel()->toString();
        $readGroup = "$code.read";

        if ($api) {
            $ns->addUse(ApiProperty::class);
            $ns->addUse(ApiResource::class);
            $ns->addUse(ApiFilter::class);
            $ns->addUse(Get::class);
            $ns->addUse(GetCollection::class);
            $ns->addUse(SearchFilter::class);
            $ns->addUse(OrderFilter::class);
            $ns->addUse(Groups::class);

            $class->addAttribute(ApiResource::class, [
                'operations' => [
                    new Literal(\sprintf('new Get(normalizationContext: ["groups" => ["%s"]])', $readGroup)),
                    new Literal(\sprintf('new GetCollection(normalizationContext: ["groups" => ["%s"]])', $readGroup)),
                ],
            ]);
        }

        // ---------------------------------------------------------------------
        // Field loop — entirely profile-driven
        // ---------------------------------------------------------------------
        foreach ($fieldNames as $field) {
            \assert(\is_string($field), "$field is not a string.");

            $propName = \preg_replace('/[^a-zA-Z0-9_]/', '_', $field);
            $propName = u($propName)->camel()->toString();

            /** @var FieldStats $stats */
            $stats = $profile->fields[$field];
            if (!$stats instanceof FieldStats) {
                // JsonlProfile::fromArray should guarantee this, but be safe.
                continue;
            }

            // Doctrine / PHP types from FieldStats
            [$phpType, $ormArgs] = $this->determineTypesFromStats($field, $stats);
//            if ($field == 'notes') {
//                dd($phpType, $ormArgs, $field, $stats);
//            }

            $property = $class->addProperty($propName)
                ->setVisibility(Visibility::Public);
            $property->setType($phpType);
            $property->setValue(null);

            // -----------------------------------------------------------------
            // Comments from FieldStats / profile
            // -----------------------------------------------------------------
            $property->addComment(\sprintf('Profile field "%s"', $field));

            // Prefer originalName from raw JSON; fall back to stats->originalName if present.
            $originalName = $decoded['fields'][$field]['originalName'] ?? null;
            if (!$originalName && \property_exists($stats, 'originalName')) {
                /** @noinspection PhpUndefinedFieldInspection */
                $originalName = $stats->originalName;
            }

            if ($originalName && $originalName !== $field) {
                $property->addComment(\sprintf('@original %s', $originalName));
            }

            $typesLabel = \method_exists($stats, 'getTypesString')
                ? $stats->getTypesString()
                : \implode(', ', $stats->types ?? []);

            $property->addComment(\sprintf(
                '@types %s (storageHint=%s)',
                $typesLabel,
                $stats->storageHint ?? 'n/a'
            ));

            $distinctLabel = \method_exists($stats, 'getDistinctLabel')
                ? $stats->getDistinctLabel()
                : (string) ($stats->distinct ?? '');

            $property->addComment(\sprintf(
                '@stats total=%d, nulls=%d, distinct=%s%s',
                $stats->total ?? 0,
                $stats->nulls ?? 0,
                $distinctLabel,
                ($stats->distinctCapReached ?? false) ? ' (capped)' : ''
            ));

            if (\method_exists($stats, 'getRangeLabel')) {
                $range = $stats->getRangeLabel();
                if ($range !== '') {
                    $property->addComment(\sprintf('@length %s', $range));
                }
            }

            if (\method_exists($stats, 'getTopOrFirstValueLabel')) {
                $topFirst = $stats->getTopOrFirstValueLabel();
                if ($topFirst !== '') {
                    $property->addComment(\sprintf('@example %s', $topFirst));
                }
            }

            if ($stats->isFacetCandidate()) {
                $property->addComment('@facetCandidate true');
            }
            if ($stats->isBooleanLike()) {
                $property->addComment('@booleanLike true');
            }

            // -----------------------------------------------------------------
            // ORM Column + Id
            // -----------------------------------------------------------------
            $isPk = ($field === $primaryField);

            // PK should not be nullable; everything else can be.
            $ormArgs['nullable'] = !$isPk;
            $property->addAttribute(Column::class, $ormArgs);

            if ($isPk) {
                $property->addAttribute(Id::class);
            }

            // -----------------------------------------------------------------
            // ApiProperty + Groups (optional, includes example)
            // -----------------------------------------------------------------
            if ($api) {
                $apiArgs   = [];
                $descParts = [];

                $descParts[] = \sprintf('types=[%s]', $stats->getTypesString());
                $descParts[] = \sprintf('distinct=%s', $stats->getDistinctLabel());
                $range       = $stats->getRangeLabel();
                if ($range !== '') {
                    $descParts[] = \sprintf('range=%s', $range);
                }
                if ($stats->isFacetCandidate()) {
                    $descParts[] = 'facetCandidate';
                }
                if ($stats->isBooleanLike()) {
                    $descParts[] = 'booleanLike';
                }

                $apiArgs['description'] = \sprintf(
                    'Profile field "%s": %s',
                    $field,
                    \implode(', ', $descParts)
                );

                $example = $stats->getTopOrFirstValueLabel();
                if ($example !== '') {
                    $apiArgs['example'] = $example;
                }

                $property->addAttribute(ApiProperty::class, $apiArgs);
                $property->addAttribute(Groups::class, [
                    'groups' => [$readGroup],
                ]);
            }

            // -----------------------------------------------------------------
            // Meili heuristics (always enabled by default, profile-driven)
            // -----------------------------------------------------------------
            if ($meili) {
                $sh    = $stats->storageHint;
                $lower = \strtolower($field);

                $meiliField = $propName;

                // Normalize PHP type (strip leading '?')
                $basePhpType  = \ltrim($phpType, '?');
                $isArrayField = ($basePhpType === 'array');
                $isIntField   = ($basePhpType === 'int');
                $isFloatField = ($basePhpType === 'float');

                // Arrays (tags, genres, etc.) and facet/boolean-like → filterable
                if ($isArrayField || $stats->isFacetCandidate() || $stats->isBooleanLike()) {
                    $filterable[] = $meiliField;
                }

                // Integer fields → *both* filterable (for RangeSlider) and sortable
                // Also explicitly treat "year" as filterable even if something goes weird.
                if (($isIntField || $lower === 'year') && !$stats->isBooleanLike()) {
                    $filterable[] = $meiliField;
                    $sortable[]   = $meiliField;
                }

                // Float fields → sortable only
                if ($isFloatField) {
                    $sortable[] = $meiliField;
                }

                // Full-text searchable:
                // Text fields that are not facets / boolean-like and not obvious IDs/codes.
                if (
                    $sh === 'text'
                    && !$stats->isFacetCandidate()
                    && !$stats->isBooleanLike()
                ) {
                    if (!\str_contains($lower, 'id') && !\str_contains($lower, 'code')) {
                        $searchable[] = $meiliField;
                    }
                }
            }
        }

        // ---------------------------------------------------------------------
        // Finalize Meili + API helper constants
        // ---------------------------------------------------------------------
        $filterable = \array_values(\array_unique($filterable));
        $sortable   = \array_values(\array_unique($sortable));
        $searchable = \array_values(\array_unique($searchable));

        $class->addConstant('FILTERABLE_FIELDS', $filterable)->setPublic();
        $class->addConstant('SORTABLE_FIELDS',   $sortable)->setPublic();
        $class->addConstant('SEARCHABLE_FIELDS', $searchable)->setPublic();

        if ($api) {
            $class->addAttribute(ApiFilter::class, [
                'filterClass' => new Literal(SearchFilter::class . '::class'),
                'properties'  => new Literal('self::FILTERABLE_FIELDS'),
            ]);

            $class->addAttribute(ApiFilter::class, [
                'filterClass' => new Literal(SearchFilter::class . '::class'),
                'properties'  => new Literal('self::SEARCHABLE_FIELDS'),
            ]);

            $class->addAttribute(ApiFilter::class, [
                'filterClass' => new Literal(OrderFilter::class . '::class'),
                'properties'  => new Literal('self::SORTABLE_FIELDS'),
            ]);
        }

        if ($meili) {
            $ns->addUse(MeiliIndex::class);
            $class->addAttribute(MeiliIndex::class, [
                'primaryKey' => $primaryKeyProperty,
                'filterable' => new Literal('self::FILTERABLE_FIELDS'),
                'sortable'   => new Literal('self::SORTABLE_FIELDS'),
                'searchable' => new Literal('self::SEARCHABLE_FIELDS'),
            ]);
        }

        $ns->add($class);
        $phpFile->addNamespace($ns);

        $code = (string) $phpFile;

        $fs = new Filesystem();

        // Map FQCN "App\\Entity\\Foo\\Bar" → "src/Entity/Foo/Bar.php"
        $relative   = \preg_replace('/^App\\\\/', '', $entityFqcn);
        $relative   = \str_replace('\\', '/', $relative);
        $targetPath = 'src/' . $relative . '.php';

        if (\is_file($targetPath) && !$force) {
            $overwrite = $io->confirm(
                \sprintf('File %s already exists. Overwrite it?', $targetPath),
                false
            );
            if (!$overwrite) {
                $io->warning(\sprintf('Skipped overwriting existing entity: %s', $targetPath));
                $this->createRepo($repoFqcn, $entityFqcn);
                return Command::SUCCESS;
            }
        }

        $fs->dumpFile($targetPath, $code);

        $this->createRepo($repoFqcn, $entityFqcn);

        $io->success(\sprintf('Created entity: %s (%s)', $entityFqcn, $targetPath));
        return Command::SUCCESS;
    }

    /**
     * Use FieldStats to determine PHP and Doctrine types.
     *
     * @return array{0:string,1:array<string,mixed>} [phpType, ormArgs]
     */
    /**
     * Use FieldStats to determine PHP and Doctrine types.
     *
     * @return array{0:string,1:array<string,mixed>} [phpType, ormArgs]
     */
    private function determineTypesFromStats(string $field, FieldStats $stats): array
    {
        $sh         = $stats->storageHint;
        $lowerField = \strtolower($field);

        $prefix = 'Types';  // @todo: fix bug and use Types::class

        // String fields that behave like integers → map to INTEGER.
        if ($sh === 'string' && $this->looksIntegerStringField($field, $stats)) {
            return [
                '?int',
                ['type' => new Literal($prefix . '::INTEGER')],
            ];
        }

        // Boolean:
        if ($sh === 'bool' || ($stats->isBooleanLike() && $this->looksBooleanField($lowerField))) {
            return [
                '?bool',
                ['type' => new Literal($prefix. '::BOOLEAN')],
            ];
        }

        // Integer
        if ($sh === 'int') {
            return [
                '?int',
                ['type' => new Literal($prefix. '::INTEGER')],
            ];
        }

        // Float
        if ($sh === 'float') {
            return [
                '?float',
                ['type' => new Literal($prefix. '::FLOAT')],
            ];
        }

        // JSON / arrays (tags, keywords, materials, etc.)
        if ($sh === 'json') {
            return [
                '?array',
                [
                    'type'    => new Literal($prefix . '::JSON'),
                    'options' => ['jsonb' => true],
                ],
            ];
        }

        // STRING/TEXT that *behave* like multi-valued arrays (tags, genres, etc.).
        if (\in_array($sh, ['string', 'text'], true) && $this->looksArrayStringField($field, $stats)) {
            return [
                '?array',
                [
                    'type'    => new Literal($prefix . '::JSON'),
                    'options' => ['jsonb' => true],
                ],
            ];
        }

        // Default: string with length; if profile says max length > 255, upgrade to TEXT.
        if ($sh === 'text' || ($stats->stringMaxLength !== null && $stats->stringMaxLength > 255)) {
            return [
                '?string',
//                ['type' => new Literal(Types::class . '::TEXT')],
                ['type' => new Literal($prefix . '::TEXT')],
            ];
        }

        $length = 255;
        if ($stats->stringMaxLength !== null && $stats->stringMaxLength > 0) {
            $length = \min($stats->stringMaxLength, 255);
        }

        return [
            '?string',
            ['length' => $length],
        ];
    }

    private function looksBooleanField(string $field): bool
    {
        return \str_starts_with($field, 'is_')
            || \str_starts_with($field, 'has_')
            || \str_ends_with($field, '_flag')
            || \str_ends_with($field, '_bool')
            || \in_array($field, ['enabled','disabled','active','deleted','featured','fetched'], true);
    }

    /**
     * Heuristic: string fields whose values look like integers (no decimals),
     * and which are not IDs/codes/boolean-like → treat as integer-ish.
     */
    private function looksIntegerStringField(string $field, FieldStats $stats): bool
    {
        if ($stats->storageHint !== 'string') {
            return false;
        }

        if ($stats->isBooleanLike()) {
            return false;
        }

        $lower = \strtolower($field);

        if (\str_contains($lower, 'id') || \str_contains($lower, 'code')) {
            return false;
        }

        $example = \trim((string) $stats->getTopOrFirstValueLabel());
        if ($example === '') {
            return false;
        }

        if (\preg_match('/^-?\d+$/', $example) !== 1) {
            return false;
        }

        if ($stats->stringMaxLength !== null && $stats->stringMaxLength > 11) {
            return false;
        }

        return true;
    }

    /**
     * STRING/TEXT that *behave* like multi-valued arrays (tags, genres, etc.).
     */
    private function looksArrayStringField(string $field, FieldStats $stats): bool
    {
        $sh = $stats->storageHint;
        if (!\in_array($sh, ['string', 'text'], true)) {
            return false;
        }

        $f = \strtolower($field);

        // Explicit "list" names
        $explicit = [
            'tags',
            'genres',
            'actors',
            'characters',
            'keywords',
            'materials',
            'subjects',
            'topics',
            'categories',
            'languages',
            'authors',
            'writers',
            'performers',
        ];
        $flaggy = [
            'is',
            'has',
            'was',
            'ids',
            'status',
            'enabled',
            'disabled',
            'active',
            'deleted',
            'featured',
            'fetched',
        ];

        if (\in_array($f, $flaggy, true)) {
            return false;
        }

        $nameLooksListy = \in_array($f, $explicit, true) || \str_ends_with($f, 's');
        if (!$nameLooksListy) {
            return false;
        }

        $example = $stats->getTopOrFirstValueLabel();
        if ($example === '') {
            return false;
        }

        return \str_contains($example, ',') || \str_contains($example, '|');
    }

    private function createRepo(string $repoFqcn, string $entityFqcn): void
    {
        $pos = \strrpos($repoFqcn, '\\');
        if ($pos === false) {
            return;
        }

        $repoNamespace = \substr($repoFqcn, 0, $pos);
        $repoClass     = \substr($repoFqcn, $pos + 1);

        $relativeRepo = \preg_replace('/^App\\\\/', '', $repoFqcn);
        $relativeRepo = \str_replace('\\', '/', $relativeRepo);
        $repoFilename = 'src/' . $relativeRepo . '.php';

        if (\file_exists($repoFilename)) {
            return;
        }

        $posEntity  = \strrpos($entityFqcn, '\\');
        $entityName = $posEntity === false ? $entityFqcn : \substr($entityFqcn, $posEntity + 1);

        $code = \sprintf(<<<'PHPSTR'
<?php
declare(strict_types=1);

namespace %s;

use %s;
use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;
use Doctrine\Persistence\ManagerRegistry;

final class %s extends ServiceEntityRepository
{
    public function __construct(ManagerRegistry $registry)
    {
        parent::__construct($registry, %s::class);
    }
}

PHPSTR,
            $repoNamespace,
            $entityFqcn,
            $repoClass,
            $entityFqcn
        );

        $fs = new Filesystem();
        $fs->dumpFile($repoFilename, $code);
    }
}

