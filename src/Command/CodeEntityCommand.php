<?php
declare(strict_types=1);

namespace Survos\CodeBundle\Command;

use DateTimeImmutable;
use Doctrine\DBAL\Types\Types;
use Doctrine\ORM\Mapping\Column;
use Doctrine\ORM\Mapping\Entity;
use Doctrine\ORM\Mapping\Id;
use Nette\PhpGenerator\ClassType;
use Nette\PhpGenerator\Literal;
use Nette\PhpGenerator\PhpFile;
use Nette\PhpGenerator\PhpNamespace;
use Nette\PhpGenerator\Visibility;
use Survos\CodeBundle\Service\GeneratorService;
use Symfony\Component\Console\Attribute\Argument;
use Symfony\Component\Console\Attribute\AsCommand;
use Symfony\Component\Console\Attribute\Option;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Style\SymfonyStyle;
use Symfony\Component\Filesystem\Filesystem;
use Symfony\Component\Validator\Constraints\Url;
use League\Csv\Reader as CsvReader;
use JsonMachine\Items;
// Optional: use survos/jsonl-bundle when available; otherwise we fallback to fgets()
use Survos\JsonlBundle\Reader\JsonlReader as SurvosJsonlReader;
use function Symfony\Component\String\u;

// adjust if your class differs

#[AsCommand('code:entity', 'Generate a PHP 8.4 Doctrine entity from a one-line JSON string.')]
final class CodeEntityCommand
{
    public function __construct(
        private GeneratorService $generatorService,
        private string $projectDir,
    ) {}

    public function __invoke(
        SymfonyStyle $io,
        #[Argument('short name of the entity to generate')]
        string $name,
        #[Option(description: 'Inline JSON; if omitted, read from STDIN')]
        ?string $json = null,
        #[Option(name: 'pk', description: 'primary key name if known')]
        ?string $primaryField = null,
        #[Option(name: 'ns', description: 'Entity namespace')]
        string $entityNamespace = 'App\\Entity',
        #[Option(description: 'Repository namespace')]
        string $repositoryNamespace = 'App\\Repository',
        #[Option(description: 'Output directory')]
        string $outputDir = 'src/Entity',
        #[Option(description: 'Path to a CSV/JSON/JSONL file (first record will be used)')]
        ?string $file = null,

    ): int {
        $io->title('Entity generator ' . $this->projectDir);

        // Input: --file (csv/json/jsonl) wins, else --json, else STDIN
        if ($file) {
            $data = $this->firstRecordFromFile($file);
        } else {
            if ($json === null) {
                $stdin = trim((string) stream_get_contents(STDIN));
                $json = $stdin !== '' ? $stdin : null;
            }
            if ($json === null) {
                $io->error('Provide --file=... (csv/json/jsonl), or --json=..., or pipe JSON on STDIN.');
                return Command::FAILURE;
            }
            $data = json_decode($json, true, 512, JSON_THROW_ON_ERROR);
        }

        if (!is_array($data) || $data === []) {
            $io->error('Could not load a non-empty first record.');
            return Command::FAILURE;
        }

        // Build entity
        $file = new PhpFile();
        $file->setStrictTypes();

        $class = new ClassType($name);
        $class->setFinal();
        $class->addComment('@generated by code:entity');

        $repoFqcn = $repositoryNamespace . '\\' . ($repoName = $name . 'Repository');
        $class->addAttribute(Entity::class, [
            'repositoryClass' => new Literal($repoName . '::class'),
        ]);

        $ns = new PhpNamespace($entityNamespace);
        // We already imported needed classes at top of THIS command;
        // here we import for the GENERATED ENTITY file:
        $ns->addUse(Entity::class);
        $ns->addUse(Column::class);
        $ns->addUse(Id::class);
        $ns->addUse(Types::class);
        $ns->addUse(DateTimeImmutable::class);
        $ns->addUse($repoFqcn);


        // Inference
        $infer = function (string $field, mixed $value): array {

            $isUrlField = str_ends_with($field, 'Url');
            $looksLikeUrl = is_string($value) && filter_var($value, FILTER_VALIDATE_URL);
            $lower = strtolower($field);

            if ($field === 'id') {
                $isInt = is_int($value) || (is_string($value) && ctype_digit($value));
                return [
                    'phpType' => $isInt ? '?int' : '?string',
                    'ormArgs' => $isInt ? ['type' => new Literal('Types::INTEGER')] : ['length' => 255],
                    'isId'    => true,
                    'isUrl'   => false,
                    'isDate'  => false,
                ];
            }

            $isIsoDate = is_string($value) && preg_match(
                    '/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|[+\-]\d{2}:\d{2})$/',
                    $value
                ) === 1;
            if ($isIsoDate || in_array($lower, ['createdat','updatedat','scrapedat','fetchedat'], true)) {
                return [
                    'phpType' => '?DateTimeImmutable',
                    'ormArgs' => ['type' => new Literal('Types::DATETIME_IMMUTABLE')],
                    'isId'    => false,
                    'isUrl'   => false,
                    'isDate'  => true,
                ];
            }

            if (is_bool($value) || in_array($lower, ['enabled','active','deleted','featured','fetched'], true)) {
                return [
                    'phpType' => '?bool',
                    'ormArgs' => ['type' => new Literal('Types::BOOLEAN')],
                    'isId'    => false,
                    'isUrl'   => false,
                    'isDate'  => false,
                ];
            }

            if (is_int($value) || in_array($lower, ['page','count','index','position','rank','duration','size'], true)) {
                return [
                    'phpType' => '?int',
                    'ormArgs' => ['type' => new Literal('Types::INTEGER')],
                    'isId'    => false,
                    'isUrl'   => false,
                    'isDate'  => false,
                ];
            }

            if (is_float($value)) {
                return [
                    'phpType' => '?float',
                    'ormArgs' => ['type' => new Literal('Types::FLOAT')],
                    'isId'    => false,
                    'isUrl'   => false,
                    'isDate'  => false,
                ];
            }

            // arrays (scalars or nested): store as JSON (prefer jsonb)
            if (is_array($value)) {
                return [
                    'phpType' => '?array',
                    'ormArgs' => [
                        'type'    => new Literal('Types::JSON'),
                        'options' => ['jsonb' => true],
                    ],
                    'isId'    => false,
                    'isUrl'   => false,
                    'isDate'  => false,
                ];
            }


            if ($isUrlField || $looksLikeUrl) {
                return [
                    'phpType' => '?string',
                    'ormArgs' => ['length' => 2048],
                    'isId'    => false,
                    'isUrl'   => true,
                    'isDate'  => false,
                ];
            }

            return [
                'phpType' => '?string',
                'ormArgs' => ['length' => 255],
                'isId'    => false,
                'isUrl'   => false,
                'isDate'  => false,
            ];
        };

        $fields = array_keys($data);
        if (!$primaryField) {
            $pkCandidates = ['id','code','sku','ssn','uid','uuid','key'];
            foreach ($pkCandidates as $c) {
                if (array_key_exists($c, $data)) { $primaryField = $c; break; }
            }
            $primaryField ??= ($fields[0] ?? null);
        }


        foreach ($data as $field => $value) {
            assert(is_string($field), "$field is not a string.");
            $propName = preg_replace('/[^a-zA-Z0-9_]/', '_', $field);
            $propName = u($propName)->camel()->toString();
            $value = $this->coerceValue($field, $value); // smart-cast CSV strings, etc.
            $meta  = $infer($field, $value);

            $property = $class->addProperty($propName)->setVisibility(Visibility::Public);
            // PHP 8.4 property hook â€” nette/php-generator supports custom visibility tokens
//            $property->setVisibility('private');              // PhpGenerator doesn't accept "private(set)"
            $property->setType($meta['phpType']);
            $property->setValue(null);

// Column / Id (class names, no leading slashes)

            $isPk = ($field === $primaryField);

// merge a DB column comment (short example of the value)
            $ormArgs = $meta['ormArgs'];
//            $ormArgs['options'] = $ormArgs['options'] ?? [];
//            $ormArgs['options']['comment'] = $this->columnComment($value);

            // @todo: be smarter
            $ormArgs['nullable'] = true;

            $property->addAttribute(Column::class, $ormArgs);
            if ($isPk) {
                $property->addAttribute(Id::class);
            }

// URL validator (imported in the GENERATED file)
// Url constraint ignores nulls by default; protocols keeps it strict.
            if (!empty($meta['isUrl'])) {
//                $property->addAttribute(Url::class, ['protocols' => ['http', 'https']]);
            }
        }

        $ns->add($class);
        $file->addNamespace($ns);

        $code = (string) $file;

        $fs = new Filesystem();
        $targetPath = rtrim($outputDir, '/').'/'.$name.'.php';
        $fs->mkdir(\dirname($targetPath));
        $fs->dumpFile($targetPath, $code);

        $io->success(sprintf('Created entity: %s (%s)', $name, $targetPath));
        return Command::SUCCESS;
    }

    private function firstRecordFromFile(string $path): array
    {
        $ext = strtolower(pathinfo($path, PATHINFO_EXTENSION));

        // CSV/TSV (header row expected; sniff delimiter; respect quotes)
        if ($ext === 'csv' || $ext === 'tsv' || $ext === 'txt') {
            $sample = file_get_contents($path, false, null, 0, 8192) ?: '';
            $delimiter = str_contains($sample, "\t") ? "\t" : ',';

            $csv = CsvReader::createFromPath($path, 'r');
            $csv->setHeaderOffset(0);
            $csv->setDelimiter($delimiter);
            $csv->setEnclosure('"'); // quoted fields supported
            // $csv->setEscape('\\'); // uncomment if you need explicit backslash escaping

            foreach ($csv->getRecords() as $row) {
                return (array) $row; // first record
            }
            return [];
        }


        // JSON (array or object at top-level) via JsonMachine (streaming)
// JSON (either an array of objects or a single object)
        if ($ext === 'json') {
            $raw = file_get_contents($path);
            if ($raw === false) {
                throw new \RuntimeException("Unable to read $path");
            }
            $decoded = json_decode($raw, true, 512, JSON_THROW_ON_ERROR);

            if (!is_array($decoded) || $decoded === []) {
                return [];
            }

            // If it's a list (array-of-objects), take the first element.
            // If it's an associative object, return it as-is.
            if (array_is_list($decoded)) {
                $first = $decoded[0] ?? null;
                return is_array($first) ? $first : [];
            }

            // Associative object at the root
            return $decoded;
        }

        // JSONL (one JSON object per line)
        if ($ext === 'jsonl' || $ext === 'ndjson') {
            // Prefer Survos bundle if present; otherwise fallback to first line
            if (class_exists(SurvosJsonlReader::class)) {
                $reader = new SurvosJsonlReader($path);
                foreach ($reader as $row) { // adjust to your bundle's iterator API if needed
                    return (array) $row;
                }
                return [];
            }

            $fh = fopen($path, 'r');
            if ($fh === false) {
                throw new \RuntimeException("Unable to open $path");
            }
            try {
                while (($line = fgets($fh)) !== false) {
                    $line = trim($line);
                    if ($line === '') {
                        continue;
                    }
                    $row = json_decode($line, true);
                    if (is_array($row)) {
                        return $row;
                    }
                    break;
                }
                return [];
            } finally {
                fclose($fh);
            }
        }

        throw new \InvalidArgumentException("Unsupported file extension: .$ext (use csv, json, or jsonl)");
    }
    private function coerceValue(string $field, mixed $value): mixed
    {
        if ($value === '' || $value === null) {
            return null;
        }
        if (!is_string($value)) {
            return $value; // already typed by JSON/JSONL
        }

        $v = trim($value);

        // If the column name looks plural and contains ',' or '|', treat as array (CSV convenience)
        $looksPlural = static function (string $name): bool {
            $n = strtolower($name);
            // crude but effective; skip common short tokens that end with 's'
            if (\in_array($n, ['is','has','was','ids','status'], true)) {
                return false;
            }
            return str_ends_with($n, 's');
        };

        if ($looksPlural($field) && (str_contains($v, ',') || str_contains($v, '|'))) {
            $parts = preg_split('/[|,]/', $v);
            $parts = array_map(static fn(string $s) => trim($s), $parts);
            $parts = array_values(array_filter($parts, static fn($s) => $s !== ''));
            return $parts; // your $infer() already maps arrays to Types::JSON (jsonb)
        }


        if ($v === '') {
            return null;
        }

        // Pipe-delimited lists => array of trimmed strings (CSV convenience)
        if (str_contains($v, '|')) {
            $parts = array_map(static fn(string $s) => trim($s), explode('|', $v));
            // remove empty elements but preserve "0"
            $parts = array_values(array_filter($parts, static fn($s) => $s !== ''));
            return $parts; // $infer() will map arrays to JSON (Types::JSON, jsonb)
        }

        // Booleans
        $l = strtolower($v);
        if (in_array($l, ['true','false','yes','no','y','n','on','off'/* ,'1','0' */], true)) {
            return in_array($l, ['true','yes','y','on','1'], true);
        }

        // ISO 8601 DateTime -> DateTimeImmutable (lets $infer pick DATETIME_IMMUTABLE)
        if (preg_match('/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|[+\-]\d{2}:\d{2})$/', $v) === 1) {
            try {
                return new DateTimeImmutable($v);
            } catch (\Throwable) {
                /* fall through */
            }
        }

        // Fields we *want* as numbers even if they had leading zeros in CSV
        $numericPreferred = [
            'page','count','index','position','rank','duration','size',
            'budget','revenue','popularity','score','rating','price','quantity'
        ];
        $preferNumeric = in_array(strtolower($field), $numericPreferred, true);

        // Integer
        if (preg_match('/^-?\d+$/', $v) === 1) {
            // Keep strings like imdbId "tt123" or zero-padded IDs as string unless preferred numeric
            $hasLeadingZero = strlen($v) > 1 && $v[0] === '0';
            if ($preferNumeric || !$hasLeadingZero) {
                // could overflow on 32-bit; PHP will promote as needed
                return (int) $v;
            }
            return $v; // preserve as string (e.g. zero-padded codes)
        }

        // Float (accepts decimal or scientific)
        if (is_numeric($v) && preg_match('/^-?(?:\d+\.\d+|\d+\.|\.\d+|\d+)(?:[eE][+\-]?\d+)?$/', $v) === 1) {
            return (float) $v;
        }

        // Otherwise leave as string
        return $v;
    }

}
