<?php
declare(strict_types=1);

namespace Survos\CodeBundle\Command;

use DateTimeImmutable;
use Doctrine\DBAL\Types\Types;
use Doctrine\ORM\Mapping\Column;
use Doctrine\ORM\Mapping\Entity;
use Doctrine\ORM\Mapping\Id;
use Nette\PhpGenerator\ClassType;
use Nette\PhpGenerator\Literal;
use Nette\PhpGenerator\PhpFile;
use Nette\PhpGenerator\PhpNamespace;
use Survos\CodeBundle\Service\GeneratorService;
use Symfony\Component\Console\Attribute\Argument;
use Symfony\Component\Console\Attribute\AsCommand;
use Symfony\Component\Console\Attribute\Option;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Style\SymfonyStyle;
use Symfony\Component\Filesystem\Filesystem;
use Symfony\Component\Validator\Constraints\Url;

#[AsCommand('code:entity', 'Generate a PHP 8.4 Doctrine entity from a one-line JSON string.')]
final class CodeEntityCommand
{
    public function __construct(
        private GeneratorService $generatorService,
        private string $projectDir,
    ) {}

    public function __invoke(
        SymfonyStyle $io,
        #[Argument('short name of the entity to generate')]
        string $name,
        #[Option(description: 'Inline JSON; if omitted, read from STDIN')]
        ?string $json = null,
        #[Option(name: 'ns', description: 'Entity namespace')]
        string $entityNamespace = 'App\\Entity',
        #[Option(description: 'Repository namespace')]
        string $repositoryNamespace = 'App\\Repository',
        #[Option(description: 'Output directory')]
        string $outputDir = 'src/Entity',
    ): int {
        $io->title('Entity generator ' . $this->projectDir);

        // JSON: --json or STDIN
        if ($json === null) {
            $stdin = trim((string) stream_get_contents(STDIN));
            $json = $stdin !== '' ? $stdin : null;
        }
        if ($json === null) {
            $io->error('Provide JSON via --json=... or pipe it on STDIN.');
            return Command::FAILURE;
        }

        $data = json_decode($json, true, 512, JSON_THROW_ON_ERROR);
        if (!is_array($data) || $data === []) {
            $io->error('JSON must decode to a non-empty object.');
            return Command::FAILURE;
        }

        // Build entity
        $file = new PhpFile();
        $file->setStrictTypes();

        $ns = new PhpNamespace($entityNamespace);
        // We already imported needed classes at top of THIS command;
        // here we import for the GENERATED ENTITY file:
        $ns->addUse(Entity::class);
        $ns->addUse(Column::class);
        $ns->addUse(Id::class);
        $ns->addUse(Types::class);
        $ns->addUse(Url::class);
        $ns->addUse(DateTimeImmutable::class);

        $class = new ClassType($name);
        $class->setFinal();
        $class->addComment('@generated by code:entity');

        $repoFqcn = $repositoryNamespace . '\\' . $name . 'Repository';
        $class->addAttribute(Entity::class, [
            'repositoryClass' => new Literal($repoFqcn . '::class'),
        ]);

        // Inference
        $infer = function (string $field, mixed $value): array {
            $isUrlField = str_ends_with($field, 'Url');
            $lower = strtolower($field);

            if ($field === 'id') {
                $isInt = is_int($value) || (is_string($value) && ctype_digit($value));
                return [
                    'phpType' => $isInt ? '?int' : '?string',
                    'ormArgs' => $isInt ? ['type' => new Literal('Types::INTEGER')] : ['length' => 255],
                    'isId'    => true,
                    'isUrl'   => false,
                    'isDate'  => false,
                ];
            }

            $isIsoDate = is_string($value) && preg_match(
                    '/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|[+\-]\d{2}:\d{2})$/',
                    $value
                ) === 1;
            if ($isIsoDate || in_array($lower, ['createdat','updatedat','scrapedat','fetchedat'], true)) {
                return [
                    'phpType' => '?DateTimeImmutable',
                    'ormArgs' => ['type' => new Literal('Types::DATETIME_IMMUTABLE')],
                    'isId'    => false,
                    'isUrl'   => false,
                    'isDate'  => true,
                ];
            }

            if (is_bool($value) || in_array($lower, ['enabled','active','deleted','featured','fetched'], true)) {
                return [
                    'phpType' => '?bool',
                    'ormArgs' => ['type' => new Literal('Types::BOOLEAN')],
                    'isId'    => false,
                    'isUrl'   => false,
                    'isDate'  => false,
                ];
            }

            if (is_int($value) || in_array($lower, ['page','count','index','position','rank','duration','size'], true)) {
                return [
                    'phpType' => '?int',
                    'ormArgs' => ['type' => new Literal('Types::INTEGER')],
                    'isId'    => false,
                    'isUrl'   => false,
                    'isDate'  => false,
                ];
            }

            if (is_float($value)) {
                return [
                    'phpType' => '?float',
                    'ormArgs' => ['type' => new Literal('Types::FLOAT')],
                    'isId'    => false,
                    'isUrl'   => false,
                    'isDate'  => false,
                ];
            }

            if ($isUrlField) {
                return [
                    'phpType' => '?string',
                    'ormArgs' => ['length' => 2048],
                    'isId'    => false,
                    'isUrl'   => true,
                    'isDate'  => false,
                ];
            }

            return [
                'phpType' => '?string',
                'ormArgs' => ['length' => 255],
                'isId'    => false,
                'isUrl'   => false,
                'isDate'  => false,
            ];
        };

        foreach ($data as $field => $value) {
            $propName = preg_replace('/[^a-zA-Z0-9_]/', '_', $field);
            $meta = $infer($field, $value);

            $property = $class->addProperty($propName);
            // PHP 8.4 property hook â€” nette/php-generator supports custom visibility tokens
            $property->setVisibility('private');              // PhpGenerator doesn't accept "private(set)"
            $property->setType($meta['phpType']);
            $property->setValue(null);

// Column / Id (class names, no leading slashes)
            $property->addAttribute(Column::class, $meta['ormArgs']);
            if (!empty($meta['isId'])) {
                $property->addAttribute(Id::class);
            }

// URL validator (imported in the GENERATED file)
// Url constraint ignores nulls by default; protocols keeps it strict.
            if (!empty($meta['isUrl'])) {
//                $property->addAttribute(Url::class, ['protocols' => ['http', 'https']]);
            }
        }

        $ns->add($class);
        $file->addNamespace($ns);

        $code = (string) $file;

        $fs = new Filesystem();
        $targetPath = rtrim($outputDir, '/').'/'.$name.'.php';
        $fs->mkdir(\dirname($targetPath));
        $fs->dumpFile($targetPath, $code);

        $io->success(sprintf('Created entity: %s (%s)', $name, $targetPath));
        return Command::SUCCESS;
    }
}
